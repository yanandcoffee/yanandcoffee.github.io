---
title: Accessibility is not a project to be completed
description: It's more than just tickets in the backlog. We're not solving for accessibility if we treat it like a project. We're mitigating our responsibilities as engineers.
date: 2020-06-21 17:00:47
tags:
- accessibility
- a11y
- community
- non-technical
---

{% picture steps.jpg %}
{% endpicture %}

Accessibility is so much bigger than just a project to be finished and completed. I think that this is because most websites and products weren't originally built with accessibility in mind. And thanks to the growing amount of [website accessibility lawsuits](https://www.essentialaccessibility.com/blog/web-accessibility-lawsuits/), it has now become a concern for most companies. [Epics](https://www.atlassian.com/agile/project-management/epics#:~:text=An%20epic%20is%20a%20large%20body%20of%20work%20that%20can,over%20a%20set%20of%20sprints.) are created, and teams are formed around addressing accessibility. But even as it is a growing concern for many companies, engineers have a lack of knowledge in writing accessible UIs. I see engineers optionally choosing to pick up accessibility work and leaving the work of accessibility to either the one person who seems to like accessibility, or leaving it to another team and having it to be their role to address accessibility. I don't think that's the right approach. It's not just about equipping a team or having one person pick up the knowledge and putting that team or person in charge of accessibility. "It'll go away by the end of the year." No. There is no "end" to accessibility work. It should be part of the World Wide Web. We all have to pick up and accept that accessibility is going to be part of our everyday workflow. It's not optional and we should all hold ourselves accountable to that.

## Two Steps Forward and One Step Back 
First off, accessibility does not directly contribute to the revenue of a business. It's one of those things that "has to be done" because it hurts the business (if the product is inaccessible) in either the form of a lawsuit, or they lose a subset of their users. Both of which are bad for business, and companies should find ways to enforce, or teach accessibility to the larger group. Most of us have a huge backlog of accessibility issues that need to be addressed. Yes, maybe forming a team around addressing accessibility is the right thing to do here. But there's more to it than that.

As an individual contributor, I want to implore you (designers, engineers, product people, etc.) to lead by example here. We don't someday magically have a fully accessible product by completing all of the accessibility tickets in the backlog. The problem remains that we're not all working toward including accessibility in our everyday workflows. Accessibility cannot be an *afterthought* when we implement new features. You cannot just fix one ticket, and then your next new feature breaks the entire flow. There is no end to that. Engineers like to treat tasks as problems to be fixed, but the "fix" here is behavioral. It's what you do. We need to change the way we work, in order to address accessibility in the present and in the future. Accessibility isn't going away.

## For Designers / Product
For designers, I've seen design mocks with accessibility requirements written in the specs and ticket/task description. I particularly liked mocks/specs that included the WAI-ARIA role to reference. I remember one of my first accessibility tickets on my new team asked to include accessibility as a layout grid with the `grid` role for our pre-existing card catalog pattern. That brought me to the [layout grids](https://www.w3.org/TR/wai-aria-practices/examples/grid/LayoutGrids.html) documentation and implementing the new feature with `grid`, `row`, and `gridcell` roles. This probably feels out of scope for a designer's work, so maybe you would work with product on this piece. Without someone defining the requirements early on in the feature, engineers are not going to implement accessibility if they have no knowledge or experience with it. The problem is not that they don't want to, but not everyone knows where to begin.

Another way to guide the engineer along with implementing accessibility in mind is to give them a keyboard navigational flow mock, which shows what the user's tab order for the experience should be. Sometimes, when you are adding a new feature to a pre-existing page, say, a search bar, it's easy to not think through the whole experience because it just makes sense that you would need a search bar added to a page that holds a lot of information. It's important here to think about _how_ the user would navigate to the search bar from the beginning to the end. Here's an example of all the accessibility concerns that you would think through if we're implementing a search bar to a pre-existing page.

1. Can the user navigate to the search bar with keyboard navigation?
2. After entering the search query, 
   - Can the user navigate to the next item (assuming the first matching search result)?
   - Can the user delete the query and return to their previous state?
   - Can the user navigate away from the search bar before or after entering a search query?

Sometimes, we *assume* the experience when we define the feature because we have a mental image of how the product should work, but without thinking through and testing all of these use cases, we may miss some accessibility concerns.

## For Engineers
For engineers, we receive mocks from designers and we implement. If the tab order is in the design mocks, we can implement that as well. But often, this is not the case, so we have to hold ourselves accountable for making sure that our feature is accessible with the entire flow. If you're using a UI library, all the correct aria attributes are usually provided in their component implementation, so you wouldn't have to worry about writing the correct aria roles and attributes. If you are writing your own component, you should bake the aria attributes into the component so that other engineers won't have to implement them manually each time. However, there are some aria attributes and roles that you may need to add to make certain elements accessible. A good example would be the X icon button that visually means "Close" to the user, but on screen readers, this may be confusing. An `aria-label` labeling it as "Close" would help here. These are little things that an engineer could learn, and to look up. A robust UI library would help in accessibility for the most part.

Outside of using a UI library, you should also think about keyboard accessibility, which is about the entire flow of all the combined UI components. Keyboard accessibility is sometimes tricky depending on _how_ all the pre-existing components play with one another. Sometimes, even the most robust components when combined doesn't make the entire UI accessible. We still need to do a quick 3-5 minute accessibility walkthrough to make sure we didn't break anything that worked before.

## Accessibility Walkthrough to Test Keyboard Navigation
This can be done by either design, engineering, or product. Start at the top of the feature, it may help to click first near the top of your UI if you don't have skip links implemented to skip to the part where you've implemented your feature. Using only `Tab`, `Shift + Tab`, `Enter`/`Space` and `Esc`, navigate through the interface. If it helps, you can think of it like a game. `Tab` moves forward and `Shift` + `Tab` moves backward. `Enter` or `Space` should trigger the interaction of the element in focus. `Esc` should be a way to exit whatever interaction you just triggered (e.g. modals or tooltips). Interact with all the elements surrounding your new feature, including getting TO and BACK from the feature. You can imagine this is how keyboard users navigate through the UI.

Let's give an example of how this would look like. Let's say the new feature you've added is an icon button that triggers a tooltip on hover/focus. The key here is that you want to make sure your new shiny addition didn't break pre-existing accessibility. You can start at the top of the page and `Tab` to the icon. Make sure that the flow to get to the icon still works. When you are focused on the icon, it should show the tooltip. `Tab` past the icon and the tooltip should disappear. `Shift` + `Tab` to go back to it and the tooltip should still appear. If this all works, then you're done.

## How Can We Maintain All This?
Ideally, we'd want some sort of audit or integration tests in place to keep our accessibility fixes in place. [Lighthouse](https://github.com/GoogleChrome/lighthouse) is a great open-source tool created by the Google Chrome team to audit web pages for performance, SEO, accessibility, etc. If you set up automation to run Lighthouse as a node module in a shell script whenever a build runs, you could audit for accessibility coverage and get reports on how accessible your web pages are per build. This would be a great way to keep your accessibility coverage in check.

For testing keyboard navigational workflows, unfortunately, Cypress does not natively support the tab key. There is an [issue](https://github.com/cypress-io/cypress/issues/299) created on Github back in 2016. There are workarounds in that thread. As of June 2020, if your integration tests are written in cypress, it seems like the approved workaround from the Cypress team would be the [cypress-plugin-tab](https://github.com/Bkucera/cypress-plugin-tab). If you set up your Cypress tests like how you would test in an accessibility walkthrough with the keyboard, then you should be covered by any new additions to that page.

## Conclusion
To wrap it all up, there are two primary issues with the way we view accessibility. One is that people _do_ think accessibility is a good thing, but they don't really do anything as a whole (designers, engineers, product, company, etc.) to accept accessibility as part of our WWW. Secondly, we treat accessibility like a laundry list of tech debt cataloged in the backlog instead of it having it as part of our everyday work life.

Accessibility is a problem to be solved by everyone working together every day to address this. Not just one ticket, or a backlog of tickets, but every person involved with developing a new feature or product on the team; designers create mocks for engineers, engineers working on a new feature or product, and product folks who define requirements and negotiate deadlines with the customers. We all need to accept that accessibility is a part of our job. It's not one-and-done. There is no finish line here. Everyone is running the marathon altogether.